---
import BaseLayout from "../../layouts/BaseLayout.astro";
import TimelineLayout from "../../layouts/TimelineLayout.astro";
import { getCollection } from "astro:content";

const posts = await getCollection("posts");

// タグの収集と投稿の関連付け
const tags = posts.reduce(
  (acc, post) => {
    post.data.tags?.forEach((tag) => {
      const normalizedTag = tag.toLowerCase();
      if (!acc[normalizedTag]) {
        acc[normalizedTag] = {
          name: tag,
          posts: [],
        };
      }
      acc[normalizedTag].posts.push(post);
    });
    return acc;
  },
  {} as Record<string, { name: string; posts: any[] }>
);

// 選択されたタグの投稿を取得
const currentTag = Astro.url.hash.slice(1).toLowerCase();
const selectedTagPosts = currentTag
  ? tags[currentTag]?.posts.sort(
      (a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
    )
  : posts.sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// クライアントサイドでの使用のための変数
const initialPosts = selectedTagPosts.map((post) => ({
  slug: post.slug,
  data: {
    title: post.data.title,
    pubDate: post.data.pubDate,
    category: post.data.category,
    tags: post.data.tags,
    description: post.data.description,
  },
}));
---

<BaseLayout
  title={currentTag ? `#${tags[currentTag]?.name || currentTag}` : "All Posts"}
>
  <div class="max-w-3xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <h1
      id="tag-title"
      class="text-3xl font-bold text-center mb-8 text-slate-900 dark:text-slate-100"
      transition:name="page-title"
    >
      {currentTag ? `#${tags[currentTag]?.name || currentTag}` : "All Posts"}
    </h1>

    <div
      id="timeline-wrapper"
      class="transition-content"
      transition:name="content"
      transition:animate="fade"
    >
      <TimelineLayout posts={selectedTagPosts} />
    </div>
  </div>
</BaseLayout>

<script define:vars={{ tags, initialPosts }}>
  let isTransitioning = false;

  // タイムラインコンテンツ更新時のトランジション時間
  const TRANSITION_DURATION = 150;

  function generateTimelineHTML(posts) {
    // 投稿を年ごとにグループ化
    const postsByYear = posts.reduce((acc, post) => {
      const year = new Date(post.data.pubDate).getFullYear();
      if (!acc[year]) acc[year] = [];
      acc[year].push(post);
      return acc;
    }, {});

    // 年ごとのセクションを生成
    return Object.entries(postsByYear)
      .sort(([a], [b]) => Number(b) - Number(a))
      .map(
        ([year, yearPosts]) => `
        <div class="year-section relative pl-8 sm:pl-32 py-6" data-year="${year}">
          <div class="year-label text-xl font-bold mb-4 text-gray-900 dark:text-gray-100">${year}</div>
          <div class="timeline-items">
            ${yearPosts
              .map(
                (post) => `
              <div class="timeline-item group relative mb-8 last:mb-0">
                <div class="timeline-stem absolute left-0 sm:left-[8.5rem] h-full w-[3px] bg-primary-200 dark:bg-primary-800/30 group-last:h-6"></div>
                <div class="timeline-dot absolute left-[-5px] sm:left-32 rounded-full bg-primary-500 border-4 border-white dark:border-gray-900 w-3 h-3 mt-1.5"></div>
                <div class="timeline-content relative flex flex-col sm:flex-row items-start mb-3">
                  <time class="timeline-date sm:absolute left-[-8rem] text-sm text-gray-600 dark:text-gray-400">
                    ${new Date(post.data.pubDate).toLocaleDateString()}
                  </time>
                  <div class="timeline-card bg-white dark:bg-gray-800 rounded-lg shadow-md p-4 w-full transition-all duration-300 ease-in-out hover:shadow-lg">
                    ${
                      post.data.category
                        ? `
                      <div class="flex items-center gap-2 mb-2">
                        <span class="category-label inline-block px-2 py-1 text-xs text-white bg-primary-500 rounded-md">
                          ${post.data.category}
                        </span>
                      </div>
                    `
                        : ""
                    }
                    <h3 class="timeline-title text-lg font-semibold mb-2">
                      <a href="/posts/${post.slug}/" 
                         class="hover:text-primary-500 transition-colors dark:text-gray-100 dark:hover:text-primary-400">
                        ${post.data.title}
                      </a>
                    </h3>
                    ${
                      post.data.description
                        ? `
                      <p class="timeline-description text-gray-600 dark:text-gray-400 text-sm">
                        ${post.data.description}
                      </p>
                    `
                        : ""
                    }
                  </div>
                </div>
              </div>
            `
              )
              .join("")}
          </div>
        </div>
      `
      )
      .join("");
  }

  async function updateContent(tag) {
    if (isTransitioning) return;
    isTransitioning = true;

    const wrapper = document.getElementById("timeline-wrapper");
    const title = document.getElementById("tag-title");
    if (!wrapper || !title) return;

    try {
      // タイトルとコンテンツのフェードアウト
      wrapper.style.opacity = "0";
      wrapper.style.transform = "translateY(10px)";
      title.style.opacity = "0";
      title.style.transform = "translateY(-5px)";

      await new Promise((resolve) => setTimeout(resolve, TRANSITION_DURATION));

      // タイトルを更新
      title.textContent = tag ? `#${tags[tag]?.name || tag}` : "All Posts";

      // フィルタリングして並び替え
      const filteredPosts = tag
        ? initialPosts.filter((post) =>
            post.data.tags?.some((t) => t.toLowerCase() === tag.toLowerCase())
          )
        : initialPosts;

      const sortedPosts = filteredPosts.sort(
        (a, b) =>
          new Date(b.data.pubDate).valueOf() -
          new Date(a.data.pubDate).valueOf()
      );

      // コンテンツを更新
      wrapper.innerHTML = generateTimelineHTML(sortedPosts);

      // フェードイン
      requestAnimationFrame(() => {
        wrapper.style.opacity = "1";
        wrapper.style.transform = "translateY(0)";
        title.style.opacity = "1";
        title.style.transform = "translateY(0)";
      });
    } catch (error) {
      console.error("Error updating content:", error);
    } finally {
      setTimeout(() => {
        isTransitioning = false;
      }, TRANSITION_DURATION);
    }
  }

  // ページロード時の初期表示処理
  function initializeContent() {
    const wrapper = document.getElementById("timeline-wrapper");
    const title = document.getElementById("tag-title");

    if (wrapper && title) {
      requestAnimationFrame(() => {
        wrapper.style.opacity = "1";
        wrapper.style.transform = "translateY(0)";
        title.style.opacity = "1";
        title.style.transform = "translateY(0)";
      });
    }
  }

  document.addEventListener("astro:page-load", initializeContent);
  window.addEventListener("hashchange", () => {
    const tag = window.location.hash.slice(1);
    updateContent(tag);
  });
</script>

<style>
  .transition-content {
    opacity: 0;
    transform: translateY(10px);
    transition:
      opacity 0.15s ease-out,
      transform 0.15s ease-out;
  }

  /* タイトルのトランジション */
  #tag-title {
    transition:
      opacity 0.15s ease-out,
      transform 0.15s ease-out;
  }

  @media (prefers-reduced-motion: reduce) {
    .transition-content,
    #tag-title {
      transition: none;
      transform: none;
    }
  }

  /* モバイル対応のスタイル */
  @media (max-width: 640px) {
    .timeline-date {
      position: static !important;
      margin-bottom: 0.25rem;
    }

    .timeline-stem {
      left: 1rem !important;
    }

    .timeline-dot {
      left: 0.75rem !important;
    }

    .year-section {
      padding-left: 3rem !重要;
    }
  }
</style>
